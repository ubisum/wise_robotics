cout << img.rows << " " << img.cols << endl;
	Size s = img.size();
	cout << s.height << " " << s.width << endl;
	
	Mat subMat = img(Rect(1, 0, img.cols-1, 100));
	//imshow("Cut Image",subMat);

    //waitKey();

	// convert to float32
	img.convertTo(Z, CV_32FC3);
	//cvtColor(Z, Z, CV_BGR2GRAY);
	Z = Z.reshape(0, Z.cols*Z.rows);

	// define criteria, number of clusters(K) and apply kmeans()
	TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 10, 1.0);
	int K = 8;
	double compactness = kmeans(Z, K, labels, criteria, 10, KMEANS_RANDOM_CENTERS, centers);
	// cout << "Labels " << labels.rows << " " << labels.cols << endl;
	cout << "Centers " << centers.rows << " " << centers.cols << endl << endl;
	cout << "Labels" << labels.rows << " " << labels.cols << endl << endl;
	cout << centers << endl << endl; 
	
	Mat converted_centers;
	centers.convertTo(converted_centers, CV_8U);
	//labels.convertTo(labels, CV_8U);
	cout << converted_centers << endl;
	cout << "Canali centers " << converted_centers.channels() << endl;
	
	// create final matrix
	labels = labels.reshape(0, img.rows);
	Mat final_matrix(labels.rows, labels.cols, CV_8UC3);
	cout << "Labels " << labels.rows << " " << labels.cols << endl;
	cout << "Canali final " << final_matrix.channels() << endl;
	
	for(int i = 0; i<labels.rows; i++)
	{
		for(int j = 0; j<labels.cols; j++)
		{
			uchar center_index = labels.at<uchar>(i,j);
			//cout << center_index << endl;
			
			Vec3b pixel_value(converted_centers.at<uchar>(labels.at<uchar>(i,j), 0), 
							  converted_centers.at<uchar>(labels.at<uchar>(i,j), 1),
							  converted_centers.at<uchar>(labels.at<uchar>(i,j), 2));
			final_matrix.at<Vec3b>(i,j) = pixel_value;
			//final_matrix.at<uchar>(i,j,0) = converted_centers.at<uchar>(labels.at<uchar>(i,j), 0);
			//cout << "Size " << sizeof(converted_centers.at<uint>(center_index, 0)) << endl;
			//final_matrix.at<uchar>(i,j,1) = converted_centers.at<uchar>(center_index, 1);
			//final_matrix.at<uchar>(i,j,1) = converted_centers.at<uchar>(labels.at<uchar>(i,j), 1);
			//final_matrix.at<uint>(i,j,2) = converted_centers.at<uint>(center_index, 2);
			
		}
	}
	
	imshow("Segmented", final_matrix);
	waitKey(0);
	
	cout << "Dimensione final: " << final_matrix.rows << " " << final_matrix.cols << endl;
	// Now convert back into uint8, and make original image
/*	center = np.uint8(center);
	res = center[label.flatten()];
	res2 = res.reshape((img.shape));

	imshow("res2",res2);
	waitKey(0);
	destroyAllWindows();*/